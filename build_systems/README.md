# Системы сборки

Когда вы пишете или будете писать статью в LaTeX, собирать огромный C++ проект,
подключать модули в Python или Go, вы столкнётесь с тем, что вам нужно будет
применить систему сборки, которая уже в свою очередь вызывает интерпретаторы
или компиляторы. Системы сборки это в какой-то степени тоже программирование,
тем не менее, их чаще называют _метапрограммированием_, потому что вы работаете
скорее с процессами, нежели пишете сам код -- они объединяют множество модулей
воедино, создавая универсальную магию, когда одна команда порождает тысячи
других, граф начинает исполняться, и вы радостно смотрите, как проходит сборка
миллион строк кода на вашем компьютере за несколько минут.

Например, Google и Yandex имеют свои навороченные системы сборки с кэшами,
облачным хранением, показывая тем самым, что это всё ещё животрепещущая тема со
многими нерешёнными вопросами в их расширяемости и стабильности. Оно настолько
заботит разработчиков, что, например, Google переписал как минимум 4 раза свою
систему сборки [Bazel](https://bazel.build/) прежде чем ей стало действительно
удобно пользоваться. На это были убиты годы разработки и одни из самых лучших
инженеров. Это всё выродилось в то, что около 83% (данные из
[этой книги](https://www.amazon.com/Software-Engineering-Google-Lessons-Programming/dp/1492082791))
из разработчиков любят систему сборки больше всего помимо еды в офисе.

Каноничное метапрограммирование очень сложное и имеет свою собственную культуру
со своими негласными правилами и практиками,например, пакеты в apt или brew надо
собирать очень определённым образом. Лично я видел только несколько людей,
которые умеют это делать на "профессиональном" уровне. Тем не менее, полезно
знать что происходит для сбора пакетов низкоуровнево, а на следующих лекциях мы
наконец-то раскроем немного магии, что происходит с самими пакетными
менеджерами.

Во всех системах сборки вы увидите несколько универсальных понятий, которые
используются повсеместно:

1. Targets. Это просто названия/имена того, что надо собирать.
1. Rules. Правила по которым стоит собирать уже Targets, обычно их единицы,
например, сборка C++ файла.
1. Dependencies. Зависимости, что нужно собрать до этого, чтобы уметь собирать
target. Часто это называют графом зависимостей, так как одни зависимости требуют
другие зависимости, а одинаковые зависимости ещё надо склеить в одни, чтобы
избежать двойной пересборки, ошибок правил одного инстанцирования и тд.
1. Toolchain. Это самый базовый набор инструментов для сбора Targets и вызовов
Rules, например, компилятор и линкер в сборке C++ проектов.

То есть системы сборки можно представить как ацикличный граф Targets, каждый
из которых собирается каким-то Rule с помощью Toolchain, а Dependencies
определяют рёбра этого графа.

# Кэширование

Каждая уважающая себя система сборки не пересобирает всё с нуля, ибо это было бы
очень долго и затратно. Все вершины ацикличного графа пересобираются, если
только поменялись его зависимости, например, исходный код какого-то файла или
объектный файл при сборке. Если вы используйте систему сборки и там нет
кэширования, можете смело выкидывать её из своего рассмотрения.

Ещё более интересные системы сборки нормализируют код, чтобы пересборка никогда
не была болезненной, если вы добавили/удалили комментарий в коде или добавили
пару пробелов. Про LLVM мы поговорим в этом курсе.

# Параллелизация

Системы сборки отлично себя показывают в парадигме data parallelization, если
вы собираете код. Все языки имеют модульную систему сборки, то есть условно
вы скорее собираете тысячи мелких файлов, чем несколько очень больших. Из-за
этого, с ростом числа ядер в процессорах, достаточно свободно можно брать и
назначать этим ядрам выполнение каких-то задач, когда данные не пересекаются.
По-простому это означает, что раз таргеты независимы, значит их можно собирать
параллельно, а практика показывает, что самый низкий уровень (когда мы собираем
просто файлы с кодом) намного больше по сравнению с остальным графом и от его
оптимизаций можно получить самый большой прирост.

Представление работы в виде графа исполнения всё больше и больше приобретает
популярность, так в Yandex есть система [Nirvana](https://habr.com/ru/company/yandex/blog/351016/),
которая в основном используется аналитиками для визуального представления графа
и его исполнения, а в Google есть [Google Cloud Dataflow](https://cloud.google.com/dataflow),
который подходит для тех же задач, а также стал расширением MapReduce парадигмы
(которая, впрочем, уже __реально устарела__), где вы просто описываете что вы
хотите сделать с данными (возможно не только Map и Reduce операции, но и другие
как Join, Flatten, GroupBy, Sort, etc), строится граф, сам оптимизируется,
исполняется и выдаёт результат пользователю.
[YT](https://habr.com/ru/company/yandex/blog/311104/), к сожалению, такого не
может и графы нужно строить самим, возможно через ту же Nirvana или shell
скрипты.

# make

Давайте уже рассматривать сами системы сборки. Одной из самых первых и уже
стандартных систем сборки в UNIX системах можно считать `make`. Система, если
говорить по-хорошему, устаревшая и имеет множество недостатков. Но для
повседневной разработки она достаточно простая. Чтобы ею пользоваться, стоит
создать файл `Makefile`. Давайте посмотрим на какой-нибудь простой пример:

```make
paper.pdf: paper.tex plot-data.png
  pdflatex paper.tex

plot-%.png: %.dat plot.py
  ./plot.py -i $*.dat -o $@
```


