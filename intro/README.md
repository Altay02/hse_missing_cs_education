# Вводная лекция

## Мотивация курса

Как инженеры мы знаем, что компьютеры отлично справляются с вычислительными
задачами. У нас есть широкий спектр инструментов, которые позволяют нам быть
более продуктивными и решать более сложные
задачи при работе над любыми проблемами, которые так или иначе что-то выполняют.
Однако многие из нас используют лишь малую часть этих инструментов: мы знаем
достаточно магических заклинаний только наизусть, и слепо копируем
команды из stackoverflow, когда мы не знаем, как что-то сделать с системой.
Примерами таких систем является `apt`, `vim`, `git`, `docker` и такой список
можно достаточно длинно продолжать.

Этот курс мы решили провести, чтобы закрыть проблему непонимания таких популярных технологий и
рассказать, что стоит за многими инструментами/фреймворками, а также повысить
вашу продуктивность, чтобы вы лучше понимали, как работают ваши повседневные
вещи. Я, лектор, решил взять на себя смелость рассказать достаточно большой и
сложный багаж знаний, который я накапливал долгое время
(в том числе и со stackoverflow, друзей, индустрии) и который, кажется, не был
рассказан ни на одном курсе Факультета Компьютерных Наук. Я не утверждаю, что я
знаю всё, я до сих пор учусь повышать свою инженерную продуктивность -- этот
процесс достаточно долгий и постоянно развивающийся, плюс у каждого свой
идеальный набор инструментов.

У меня нет задачи заставить вас использовать что-то, что я использую. Я хочу
показать различные варианты, рассказать интересные идеи за ними и показать как
оно работает изнутри, чтобы оно перестало казаться "магией".

## Структура

Будет от 10 до 14 лекций, каждая из которых затронет какую-то тему.
[Темы](../README.md) по большей части не связаны между собой, но каждая
так или иначе всплывает в работе инженера на системах Linux и MacOS
(извините, Windows почти не затронем), чтении и написании статьей или
документации, при запуске сервисов, виртуализации, open-source культуры,
тестирования, сборки и воспроизведении результатов других.

### Оценка

Будет от 2 до 4 домашних заданий. Они не будут сложными, например, идеи, которые
на начало курса есть у лектора:

- Shell scripting
- Задачи на поиграться с git
- gdb coredumps debug
- Опубликовать своё резюме в LaTeX через github actions

Финальная оценка будет ставиться как среднее всех домашних заданий и только из
них, экзамена не будет, семинаров тоже, обязательного посещения тоже нет. Лекции
будут записываться и выкладываться на youtube по ссылке TODO. Единственное
преимущество быть на лекции -- возможность задавать вопросы лично и получать
быстрые ответы. Текстовые лекции не будут такими захватывающими, потому что в
этом курсе много надо показывать. Также если несколько людей найдут достаточное
количество опечаток в конспектах или хорошие замечания, могут рассчитывать на
автоматы, человеку, который найдёт, исправит больше всего опечаток и дополнит
интересно лекции (а я приму pull request), полагается автомат.

Также подписывайтесь на телеграм канал TODO, я там буду делать объявления. Чата
не будет, если есть вопросы, пишите напрямую [мне в Telegram](http://t.me/Danlark).

# Shell

У компьютеров сейчас уже очень много интерфейсов работы, будь то полностью
графический как в Windows, будь то уже голосовой как у ассистентов. Но они
достаточно ограничены в своих действиях -- мы пока не умеем голосом объяснять
любые команды или UX может быть ограниченым. Исторически так сложилось (и по
существу), что текстовые интерфейсы самые гибкие и намного проще для реализации.
Откуда появился добрый старый всем известный Shell.

Все платформы, которые вы используете имеют тот или иной shell. Сегодня мы
поговорим о самом популярном shell -- Bourne Again SHell, или "bash" как его
ещё называют. Чтобы открыть терминал, который запустит вам bash на Ubuntu,
надо ввести shortcut `Ctrl + Alt + T`, на MacOS нет дефолтного шортката, поэтому
надо через поиск или графический интерфейс. Если у вас что-то другое, вы уже
сами знаете как открывать терминал.

Когда вы открываете терминал с bash, у вас перед глазами будет что-то похожее
на следующее:

```console
danlark@danlark:~$
```

Это основной текстовый интерфейс. Он показывает вам кто вы на какой машине и
где вы находитесь. Первый `danlark` -- это кто я, второй `danlark` --
машина на которой я нахожусь. `~` -- стандартное обозначение `home` директории
в вашей системе, `$` обозначает, что вы не root пользователь.

Дальше shell предоставляет вам исполнять команды

```console
danlark@danlark:~$ whoami
danlark
danlark@danlark:~$ hostname
danlark
```

Как они исполняются? Как и в языках программирования, в Shell есть глобальные
переменные, которые вас окружают. В bash одна из основных глобальных переменных
это `$PATH`, ещё такие переменные называются переменными окружения, чтобы их
вывести, надо обязятельно перед ними поставить знак `$`, а команда `echo` умеет
выводить **аргументы командной строки**, причём `echo` ничего не знает про
`$PATH` -- сам bash раскрывает эту переменную при исполнении.

```console
danlark@danlark:~$ echo PATH
PATH
danlark@danlark:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Теперь, когда вы пишите любую команду, shell поочередно смотрит на все пути
указанные в `$PATH` и исполняет эту команду. Конфликты решаются по первому
попавшемуся пути в переменной. Например, у меня бинарный файл `whoami` на самом
деле лежит по `/usr/bin/whoami`. Вы можете это узнать написав команду `which`.

```console
danlark@danlark:~$ which whoami
/usr/bin/whoami
danlark@danlark:~$ which which
/usr/bin/which
```

Вы также можете переопределять эти переменные перед командами, например,

```console
danlark@danlark:~$ PATH=/usr/local/bin whoami
bash: whoami: command not found
danlark@danlark:~$ PATH=/usr/bin whoami
danlark
```

С аргументами в shell есть сложности -- основной разделитель является пробелом,
а иногда аргументы хочется иметь с пробелами, для этого используют так
называемую технику escaping через обратный слеш `\`, а также ещё кавычки,
например, при навигации по директориям, если какая-то названа `hse course`, то
её создавать или в неё входить можно так

```console
danlark@danlark:~$ mkdir hse\ course
danlark@danlark:~$ cd "hse course"
danlark@danlark:~/hse course$ pwd
/home/danlark/hse course
danlark@danlark:~/hse course$
```

Кавычки можно брать как и одинарные, так и двойные. И если вам хочется какую-то
кавычку использовать в названии, то её можно окружить кавычками другого типа и
всё будет работать, пример:

```console
danlark@danlark:~$ mkdir 'hse\ "course'
danlark@danlark:~$ cd 'hse\ "course'
danlark@danlark:~/hse\ "course$
```

Кстати, про навигацию внутри файловой системы. В Linux системах всё находится
под одной точкой, называемой "root" или `/`. Все остальные файлы, девайсы
находятся под `/`. Основные команды для навигации такие:

```console
danlark@danlark:~$ pwd
/home/danlark
danlark@danlark:~$ cd /home
danlark@danlark:/home$ pwd
/home
danlark@danlark:/home$ cd ..
danlark@danlark:/$ pwd
/
danlark@danlark:/$ cd ./home
danlark@danlark:/home$ pwd
/home
danlark@danlark:/home$ cd danlark
danlark@danlark:~$ pwd
/home/danlark
danlark@danlark:~$ ../../bin/echo hello
hello
```

Путь, начинающийся с `/` -- абсолютный путь, иначе он относительный. `.` это
текущая директория, `..` -- родительская директория (предыдущая до последнего
`/`), `pwd` это команда print working directory.

Стоит отметить, что команда `cd -` вернёт вас на предыдущую директорию, в
которой вы были, бывает полезно, когда вы прыгаете между двумя директориями. А
`cd ~` вернёт вас в вашу home директорию.

Почти все команды работают с текущей директорией, например, чтобы посмотреть,
что за файлы и папки находятся в текущей директорории, достаточно запустить
команду `ls` -- list.

```console
danlark@danlark:~$ ls
 -                                       Documents
 1_5zVzH8TuK1M-oxVnVEY1GA.png            Downloads
 2020-07-29-155724_1113x656_scrot.png    First
 2020-07-29-163555_1585x422_scrot.png    format-benchmark
...
```

Чтобы посмотреть больше информации, у `ls` есть опция `-l`, и вывод будет
более полным

```console
danlark@danlark:~$ ls -l
total 250928
drwxr-xr-x  1 danlark primarygroup    224044 May  4 13:11  dir_name
-rw-r-----  1 danlark primarygroup    110021 Jul 29 15:45  1_5zVzH8TuK1M-oxVnVEY1GA.png
-rw-r-----  1 danlark primarygroup    144485 Jul 29 15:57  2020-07-29-155724_1113x656_scrot.png
-rw-r-----  1 danlark primarygroup     92167 Jul 29 16:35  2020-07-29-163555_1585x422_scrot.png
-rw-r-----  1 danlark primarygroup     92031 Jul 29 16:36  2020-07-29-163646_1585x418_scrot.png
```

На некоторых современных bash `ls -l` можно просто заменить на `ll`.

```console
drwxr-xr-x  1 danlark primarygroup    224044 May  4 13:11  dir_name
```

Разберём, что оно выводит. `d` бит показывает, что это директория, первый `rwx`
показывает, что директория может читаться, перезаписываться и входиться от
пользователя `danlark`, вторые `r-x` показывают, что группа `primarygroup`
может читать и заходить, третьи показывают `r-x`, что все остальные помимо
owner и owner group могут читать и заходить. Единица после доступов показывает
количество hard link на директорию, но это выходит за рамки нашей лекции.
Так как битов по 3, то их представляют в 8-ричной системе счисления и эти
доступы можно менять, например

```console
danlark@danlark:~$ chmod 775 dir_name
danlark@danlark:~$ ls -ld dir_name
drwxrwxr-x 2 danlark primarygroup 4096 Aug 16 15:55 dir_name
```

Остальные интересные команды для работы с директориями это `mv $src $dst`
(move), `cp $src $dst` (copy), `mkdir $dir` (make directory), `rm $file` (remove),
`rmdir $dir` (remove empty directory), `rm -r $dir` (remove recursive),
`touch $file` (touch a file, то есть создание файла).

Если вы хоть когда-то хотите что-то большее узнать про какую-либо команду, её
опции и прочее, всегда можно ввести `man $cmd` или `cmd --help`, которые должны
помочь.

В `man` навигация идёт обычными стрелками, но если вы хотите что-то поискать,
то shortcuts следующие:

* / search string – ищёт “search string” в текущем man
* n -- к следующему совпадению строки
* shift + n -- предыдущее совпадение строки

## Super User

Вы скорее всего уже часто сталкивались с тем, что вам приходится писать `sudo`
в командах, например, при установке пакетов. `sudo` обозначает "super user do" и
нужно, когда вам нужны доступы к папкам/файлам, которые защищены от всех
остальных пользователей. Например, при установке пакетов в `/usr/bin`. Это
создано для безопасности, поэтому будьте осторожны всегда, когда вас просят
что-то сделать с sudo привелегиями, например, не запускайте сторонние бинарные
файлы с этим доступом. Пароль от `sudo` по умолчанию хранится 15 минут, то есть
вам не надо будет вводить новый пароль при повторном использовании `sudo`. Если
же вы хотите всегда быть в root в каких-то операциях, вы можете войти в `su`
(super user) мод

```console
danlark@danlark:~$ sudo su
[sudo] password for danlark:
root@danlark:/home/danlark#
```

## Межпроцесное взаимодействие

Запускать программы по одной очень хорошо, но иногда хотелось бы вывести вывод
программы в файл или на вход другой программы. Для этого в shell есть множество
способов, основанные на так называемых потоках или реже, файловых дескрипторах.

Самыми простые формы перенаправления являются `<file` и `>file`, первое
обозначает, что вход программы должен браться из `file`, а последнее означает,
что `file` должен перезаписаться выводом программы, `>>file` означает, что в
`file` будет добавлен вывод программы. Рассмотрим простешие примеры (`cat`,
кстати, команда для прочтения файла или stdin, если запущена без аргументов)

```console
danlark@danlark:~$ echo hello >hello.txt
danlark@danlark:~$ cat hello.txt
hello
danlark@danlark:~$ cat <hello.txt # нет аргуметов, просто запуск из stdin hello.txt
hello
danlark@danlark:~$ cat <hello.txt >hello2.txt
danlark@danlark:~$ cat hello2.txt
hello
danlark@danlark:~$ echo " world" >>hello2.txt
danlark@danlark:~$ cat hello2.txt
hello world
```

Также выход одной программы можно перенаправлять на вход другой через оператор
pipe `|`, например

```console
danlark@danlark:~$ ls -l | head -n 3
total 250712
-rw-r-----  1 danlark primarygroup    110021 Jul 29 15:45 1_5zVzH8TuK1M-oxVnVEY1GA.png
-rw-r-----  1 danlark primarygroup    144485 Jul 29 15:57 2020-07-29-155724_1113x656_scrot.png
```

Или что-то более сложное

```console
danlark@danlark~$ curl --head -s google.com | grep -i content-length | cut --delimiter=' ' -f2
219
```

Последняя команда взяла header сайта google.com, поискала с помощью `grep` слово
`content-length` в любом регистре и вывела 2-й токен с разделителем пробел.

Помните, что иногда в файлы нельзя ничего записать

```console
danlark@danlark:~$ touch hello.txt
danlark@danlark:~$ chmod 000 hello.txt
danlark@danlark:~$ echo hello >hello.txt
bash: hello.txt: Permission denied
```

Но для некоторых может стать удивлением, что в `hello.txt` нельзя записать с
sudo

```console
danlark@danlark:~$ sudo echo hello >hello.txt
bash: hello.txt: Permission denied
```

Так происходит, потому что echo запускается с `sudo`, а `>hello.txt` это всего
лишь перенаправление, которое контролируется самим bash. Чтобы избежать такого
в будущем, стоит использовать `sudo su`, как писалось выше или окружать
полностью команду в sudo

```console
danlark@danlark:~$ sudo echo hello >hello.txt
bash: hello.txt: Permission denied
danlark@danlark:~$ sudo bash -c 'echo hello >hello.txt'
danlark@danlark:~$ sudo cat hello.txt
hello
danlark@danlark:~$ sudo cat <hello.txt
bash: hello.txt: Permission denied
```

Также если вы хотите исключить весь вывод, стандартым способом является
перенаправление stdout `>/dev/null`.

Стоит отметить, что ещё существует `2>file`, это перенаправление `stderr` в
`file`, если вы хотите полностью исключить любой вывод в консоль, лучший способ
`>/dev/null 2>/dev/null`. А если вам надо что-то поискать по `stderr`, можно
его перенаправить в `stdout` с помощью `2>&1 | grep $your_token`.

```console
danlark@danlark:~$ man | grep you
What manual page do you want?
For example, try 'man man'.
danlark@danlark:~$ man 2>&1 | grep you
What manual page do you want?
danlark@danlark:~$ man 2>&1 >/dev/null | grep you
What manual page do you want?
danlark@danlark:~$ man 2>&1 2>/dev/null | grep you
What manual page do you want?
danlark@danlark:~$ man 2>/dev/null | grep you
```

## Множество команд

Вы можете писать множество команд через `&&`, где часть справа выполнится только
если корректно (с кодом возврата 0) завершилась.

```console
danlark@danlark:~$ ls | head -n 5 && echo OK!
1_5zVzH8TuK1M-oxVnVEY1GA.png
2020-07-29-155724_1113x656_scrot.png
2020-07-29-163555_1585x422_scrot.png
2020-07-29-163646_1585x418_scrot.png
2020-07-29-163706_1582x421_scrot.png
OK!
```

Иногда вы можете встретить команду `&`, она делает detach процесса -- это
значит, что процесс принадлежит терминалу (при его закрытии, он умрет), но
shell этот процесс не блокирует, то есть можно другие команды выполнять. Чтобы
быть увеременным, что ваша команда выполнится в фоне даже если закрыть терминал,
можно использовать tmux (будет в конце лекции), либо использовать команду
`nohup`.

```console
danlark@danlark:~$ nohup ./server --port=1488 &
```

Всё, сервер работает и даже если закроете терминал.

## Aliases

Если вам не нравится печатать долго какую-то команду, то в bash можно
выстраивать алиасы. А именно в вашей home dir должен быть файл `.bashrc`,
в котором можно в конце писать алиасы, которые можно дальше пользоваться в bash.

```sh
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias lah='ls -lah'
alias lmao='touch all'
```

## TAB completion

Когда вы ходите по директориям или работаете в git, могут предоставляться так
называемые tab-completions, например, если я хочу пойти в какую-то директорию с
префиксом `Do`, то я пишу `cd Do` и жму TAB 1 или 2 раза и появляются варианты

```console
danlark@danlark:~$ cd Do
Documents/ Downloads/
```

И вы можете видеть весь список предложенных. В итоге достаточно хорошим правилом
является жать TAB примерно всегда, чтобы быстрее навигироваться по директориям
или чтобы автодополнялись команды. К сожалению, в bash не самая лучшая поддержка
tab-completion.

## zsh, fish

Bash, к сожалению, достаточно ограничен в своём функционале. Существуют
множество расширений shell, одни из самых примечательных это
[oh my zsh](https://ohmyz.sh/) и [fish](https://fishshell.com/). Последний не
совсем совместим с bash, поэтому для начала я рекомендую использовать просто
oh my zsh.

Он лучше имеет дополнять по tab, умеет предлагать выборы при повторном нажимании
tab. Одна из отличительных способностей этих shell является то, что они могут
искать по истории ваших команд, когда в bash вы только можете взять предыдущие
команды нажимая на стрелку вверх. Например

```zsh
➜  ~ mv Down
# Нажимаю стрелку вверх
➜  ~ mv Downloads/big_max_cost_flow.in .
```

И команда, которую я делал недавно, вывелась.

fish ещё более умно и выдаёт всякие предложения исходя из частоты использования
и тд.

Мой совет -- откажитесь от обычного bash и используйте zsh или fish. Чтобы
их запускать при открытии терминала, существует один всегда работающий способ,
в конце `.bashrc` добавить команду `exec zsh` или `exec fish`. В интернете полно
туториалов по кастомизации этих терминалов, возьмите тот, который вам нравится
больше всего. У меня нет задачи заставить вас пользоваться тем, чем я пользуюсь.

[Пример](https://github.com/TmLev/notes/blob/master/zsh.md) установки и кастомизации zsh от TmLev.

## tmux

[tmux](https://github.com/tmux/tmux/wiki) -- отдельная утилита для шелла,
которая расчитана на мультиработу и хранение состояний терминалов. Например,
каждый раз вам надо открывать новый терминал чтобы сделать что-то интересное,
как ни странно, если вы делаете какую-то долгую работу и отправляете машину в
спящий режим, случайно закрываете терминал или сеть обрывается с сервером, то
процесс остановится. tmux создан для решений этих проблем, он работает в фоне
всегда путём сохранения state ваших терминальных окон.

В tmux можно создавать сессии, в которых вы работаете, сессии состоят из окон --
это наборы терминалов, а окна из панелей -- это отдельные обычные терминалы.
Вот некоторые шорткаты, как работать с панелями

* Ctrl+b " -- создать новую панель горизонтально от выбранной
* Ctrl+b % -- создать новую панель вертикально от выбранной
* Ctrl+b arrow key -- смена панели
* Ctrl+b c -- создание нового окна
* Ctrl+b n -- переключение на след окно
* Ctrl+b p -- переключение на пред окно
* Ctrl+b w -- показ всех сессий и окон и интерфейс для переключение
* Ctrl+b ? -- показ всех команд
* Ctrl+d, exit -- выход из панели, возвращение на предыдущую панель

Более подробный список команд можно найти [здесь](https://gist.github.com/Bekbolatov/6840069e51382965fdad) и [здесь](https://gist.github.com/MohamedAlaa/2961058).

# Полезные команды

* `cd`, `mkdir`, `touch`, `rm`, `touch`, `pwd`, `ls` -- см. выше
* `sort`, `uniq` -- сортировка и вывод уникальных
  (вход должен быть отсортированным)
* `grep`, `cut` -- поиск по регулярному выражению (см. след лекцию) и сплит строк
* `head`, `tail` -- вывод первых и последних строк
* `wc` -- подсчёт количества байт, строк в файле итд
* `df` -- статистика использованного места на машине
* `cat`, `tac` -- вывод файла с начала или с конца соответственно
* `echo` -- повторение аргументов
* `find` -- мощная команда для поиска в директории
* `chmod`, `chown`, `sudo` -- изменение permissions и овнеров, работа в режиме super user
* Используйте перенаправления `>, <, 2>, >>, 2>>, 2>&1, |`. Вспомните, что
  каждое означает
